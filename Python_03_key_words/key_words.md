![Основы Python](https://cs.sberbank-school.ru/inline?access_token=eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2MzA3NTc3NDIsImlhdCI6MTYzMDY3MTM0MiwiZmlsZV91dWlkIjoiM2I1ODM0OTItNDdlZi0xMWVhLTk1OTUtMDA1MDU2MDExYjY4In0.gagCTgtgYvNkqWcahAmfYXSoMJBPlJLRubWgaxxov3I "Основы Python")

### Несколько советов

При написании кода иногда приходится использовать две, три и даже больше переменных. Каждая из них должна иметь свой уникальный идентификатор. Этот идентификатор может быть практически любым, однако стоит придерживаться некоторых правил, которые позволят легче перечитывать свой собственный код. Представьте, что вы написали некую программу, оставили ее на какое-то время и спустя месяц решили внести дополнения. Если вы называли ваши переменные как попало, тогда вам понадобится потрудиться, чтобы вспомнить что происходит внутри кода. Гораздо удобней, когда в имя переменной закладывается ее смысл. Давайте разберем на примере. Допустим, нам надо написать программу, которая переводит цифры в их символьное обозначение с помощью символа "\*".

``` {.language-python}
zero =  ["  ***  ", " *   * ", "*     *", "*     *", "*     *"," *   * ","  ***  "]
one =   [" * ", "** ", " * ", " * ", " * ", " * ", "***"]
two =   [" *** ", "*   *", "*  * ", "  *  ", " *   ", "*    ", "*****"]
three = [" *** ", "*   *", "    *", "  ** ", "    *", "*   *", " *** "]
four =  ["   *  ", "  **  ", " * *  ", "*  *  ", "******", "   *  ", "   *  "]
five =  ["*****", "*    ", "*    ", " *** ", "    *", "    *", "**** "]
six =   ["*    ", "*    ", "*    ", "**** ", "*   *", "*   *", "**** "]
seven = ["*****", "    *", "   * ", "  *  ", " *   ", "*    ", "*    "]
eight = [" *** ", "*   *", "*   *", " *** ", "*   *", "*   *", " *** "]
nine =  [" ****", "*   *", "*   *", " ****", "    *", "    *", "    *"]

digits = [zero, one, two, three, four, five, six, seven, eight, nine]
number = '0123456789'
for row in range(7):
line = ""
for digit in number:
line += digits[int(digit)][row] + " "
print(line)
```

Для начала мы выписали все цифры в виде списков из 7 элементов. Каждый элемент - ряд в записи преобразованного числа. Т.е. вот так будет выглядеть цифра 8, можно посчитать и убедиться, что количество рядов равно 7:

``` {.language-python}
 ***     # row = 0
*   *    # row = 1  
*   *    # row = 2  
***
*   *     ...
*   *
***     # row = 6 
```

Затем мы записали список **digits**, который содержит в себе все отдельные списки от нуля до 9.

Далее присваиваем строковое значение переменной **number** - это наше число, которое мы хотим перевести.

После начинаем цикл для каждого ряда **row**. В каждом ряду мы присваиваем переменной **line** пустое строковое значение, для того, чтобы каждый раз по новой ее заполнять. Далее начинаем второй цикл для того, чтобы прочитать каждую цифру **digit** в **number** отдельно. Для каждой цифры **digit** мы заполняем строчку **line**. Заполнение происходит следующим образом: **int(digit)**- перевод данных из строкового типа в числовой. Т.е. символ '1' становится числом 1. Это нужно для того, чтобы обратиться к определенному элементу в списке **digits**, поскольку обращение происходит только с помощью типа **int**. Таким образом с помощью данной записи **digits[int(digit)][row]**мы выбираем конкретный элемент необходимой нам цифры (Об этом более подробно можно будет прочитать в разделе "Списки"). К выбранному нами сочетанию символов мы добавляем несколько пустых пробелов **"   "**, чтобы появилось расстояние между цифрами и был читаемый вид. После этого мы выводим на экран собранную линию из частей цифр для каждого ряда **print(line)**.

``` {.language-python}
  ***     *    ***    ***      *    *****  *      *****   ***    ****
*   *   **   *   *  *   *    **    *      *          *  *   *  *   *
*     *   *   *  *       *   * *    *      *         *   *   *  *   *
*     *   *     *      **   *  *     ***   ****     *     ***    ****
*     *   *    *         *  ******      *  *   *   *     *   *      *
*   *    *   *      *   *     *        *  *   *  *      *   *      *
***    ***  *****   ***      *    ****   ****   *       ***       *   
```

Теперь давайте попробуем записать эту же самую программу, только в качестве имен переменных будем использовать первое, что придет в голову:

``` {.language-python}
var1 =  ["  ***  ", " *   * ", "*     *", "*     *", "*     *"," *   * ","  ***  "]
var2 =   [" * ", "** ", " * ", " * ", " * ", " * ", "***"]
var3 =   [" *** ", "*   *", "*  * ", "  *  ", " *   ", "*    ", "*****"]
var4 = [" *** ", "*   *", "    *", "  ** ", "    *", "*   *", " *** "]
var5 =  ["   *  ", "  **  ", " * *  ", "*  *  ", "******", "   *  ", "   *  "]
var6 =  ["*****", "*    ", "*    ", " *** ", "    *", "    *", "**** "]
var7 =   ["*    ", "*    ", "*    ", "**** ", "*   *", "*   *", "**** "]
var8 = ["*****", "    *", "   * ", "  *  ", " *   ", "*    ", "*    "]
var9 = [" *** ", "*   *", "*   *", " *** ", "*   *", "*   *", " *** "]
var10 =  [" ****", "*   *", "*   *", " ****", "    *", "    *", "    *"]
array = [var1, var2, var3, var4, var5, var6, var7, var8, var9, var10]
string = '0123456789'
for i in range(7):
a = ""
for l in string:
a += array[int(l)][i] + " "
print(a)
```

Согласитесь, что теперь надо потрудиться, чтобы прочитать довольно простой код. Чтобы не попадать в такие ситуации, лучше сразу приучать себя присваивать "говорящие" имена. Стоит отдельно отметить, что использование маленькой буквы "l"(эль), и заглавной буквы "I"(ай) в качестве однобуквенных идентификаторов при использовании некоторых шрифтов может вызывать путаницу, так как они схожи с цифрой 1. Такая же история с заглавной буквой "O" и нулем.

### Ключевые слова

В стандартном пакете Python 3 существуют ключевые слова, которым отведен определенный функционал. Далее мы перечислим их, чтобы вы ознакомились с ними и в будущем избежали совпадений в названии своих переменных.

Ключевые слова:

-   **False** - показатель ложности для булева типа;
-   **True** - показатель истинности для булева типа;
-   **None** - "пустой" объект;
-   **and** - логический оператор И;
-   **with/as** - менеджер контекста;
-   **assert** - условие, вызывающее исключение, если условие ложно;
-   **break** - оператор выхода из цикла;
-   **class** - тип, состоящий из методов и атрибутов;
-   **continue** - оператор перехода на следующую итерацию цикла;
-   **def** - обозначение функции;
-   **del** - определение функции;
-   **elif** - условный оператор в противном случае-если;
-   **else** - условный оператор в противном случае;
-   **except** - оператор перехвата исключения;
-   **finally** - выполняет инструкцию вне зависимости от исключения;
-   **for** - оператор цикла for;                
-   **from** - оператор импорта из модуля;
-   **global** - оператор создания доступности обращения к переменной за пределами функции;
-   **if** - условный оператор если;
-   **import**- оператор импорта модуля;
-   **in** - оператор проверки на вхождение;
-   **is** - оператор проверки ссылаются ли 2 объекта на одно место в памяти;
-   **lambda** - определение анонимной функции;
-   **nonlocal** - оператор создания доступности обращения к переменной в объемлющей инструкции;
-   **not** - логический оператор не;
-   **or** - логический оператор или;
-   **pass** - ничего не выполняющий оператор;
-   **raise**- оператор вызова исключения;
-   **return** - оператор возвращения результата;
-   **try** - выполнить инструкции, перехватив исключения;
-   **while**- условно-циклический оператор до тех пор;
-   **yield** - определение функции-генератора.

Помимо ключевых слов, в Python 3 присутствуют встроенные функции:

-   **bool(x)** - преобразование к типу bool, использующая стандартную процедуру проверки истинности. Если х является ложным или опущен, возвращает значение False, в противном случае она возвращает True.
-   **bytearray([источник [, кодировка [ошибки]]])** - преобразование к bytearray. Bytearray - изменяемая последовательность целых чисел в диапазоне 0≤X\<256. Вызванная без аргументов, возвращает пустой массив байт.
-   **bytes([источник [, кодировка [ошибки]]])** - возвращает объект типа bytes, который является неизменяемой последовательностью целых чисел в диапазоне 0≤X\<256. Аргументы конструктора интерпретируются как для bytearray().
-   **complex([real[, imag]])** - преобразование к комплексному числу.
-   **dict([object])**- преобразование к словарю.
-   **float([X])** - преобразование к числу с плавающей точкой. Если аргумент не указан, возвращается 0.0.
-   **frozenset([последовательность])**- возвращает неизменяемое множество.
-   **int([object], [основание системы счисления])** - преобразование к целому числу.
-   **list([object])** - создает список.
-   **memoryview([object])** - создает объект memoryview.
-   **object()** - возвращает безликий объект, являющийся базовым для всех объектов.
-   **range([start=0], stop, [step=1])** - арифметическая прогрессия от start до stop с шагом step.
-   **set([object])** - создает множество.
-   **slice([start=0], stop, [step=1])** - объект среза от start до stop с шагом step.
-   **str([object], [кодировка], [ошибки])** - строковое представление объекта. Использует метод \_\_str\_\_.
-   **tuple(obj)** - преобразование к кортежу.
-   **abs(x)** - возвращает абсолютную величину (модуль числа).
-   **all(последовательность)** - возвращает True, если все элементы истинные (или, если последовательность пуста).
-   **any(последовательность)** - возвращает True, если хотя бы один элемент - истина. Для пустой последовательности возвращает False.
-   **ascii(object)** - как repr(), возвращает строку, содержащую представление объекта, но заменяет не-ASCII символы на экранированные последовательности.
-   **bin(x)** - преобразование целого числа в двоичную строку.
-   **callable(x)** - возвращает True для объекта, поддерживающего вызов (как функции).
-   **chr(x)** - возвращает односимвольную строку, код символа которой равен x.
-   **classmethod(x)** - представляет указанную функцию методом класса.
-   **compile(source, lename, mode, ags=0, dont\_inherit=False)** - компиляция в программный код, который впоследствии может выполниться функцией eval или exec. Строка не должна содержать символов возврата каретки или нулевые байты.
-   **delattr(object, name)** - удаляет атрибут с именем 'name'.
-   **dir([object])** - список имен объекта, а если объект не указан, список имен в текущей локальной области видимости.
-   **divmod(a, b)** - возвращает частное и остаток от деления a на b.
-   **enumerate(iterable, start=0)** - возвращает итератор, при каждом проходе предоставляющем кортеж из номера и соответствующего члена последовательности.
-   **eval(expression, globals=None, locals=None)** - выполняет строку программного кода.
-   **exec(object[, globals[, locals]])**- выполняет программный код на Python.
-   **filter(function, iterable)** - возвращает итератор из тех элементов, для которых function возвращает истину.
-   **format(value[,format\_spec])**- форматирование (обычно форматирование строки).
-   **getattr(object, name ,[default])** - извлекает атрибут объекта или default.
-   **globals()** - словарь глобальных имен.
-   **hasattr(object, name)** - имеет ли объект атрибут с именем 'name'.
-   **hash(x)** - возвращает хеш указанного объекта.
-   **help([object])** - вызов встроенной справочной системы.
-   **hex(х)** - преобразование целого числа в шестнадцатеричную строку.
-   **id(object)**- возвращает "адрес" объекта. Это целое число, которое гарантированно будет уникальным и постоянным для данного объекта в течение срока его существования.
-   **input([prompt])** - возвращает введенную пользователем строку. Prompt - подсказка пользователю.
-   **isinstance(object, ClassInfo)** - истина, если объект является экземпляром ClassInfo или его подклассом. Если объект не является объектом данного типа, функция всегда возвращает ложь.
-   **issubclass(класс, ClassInfo)** - истина, если класс является подклассом ClassInfo. Класс считается подклассом себя.
-   **iter(x)** - возвращает объект итератора.
-   **len(x)** - возвращает число элементов в указанном объекте.
-   **locals()**- словарь локальных имен.
-   **map(function, iterator)** - итератор, получившийся после применения к каждому элементу последовательности функции function.
-   **max(iter, [args ...] \* [, key])** - максимальный элемент последовательности.
-   **min(iter, [args ...] \* [, key])**- минимальный элемент последовательности. next(x) - возвращает следующий элемент итератора.
-   **oct(х)** - преобразование целого числа в восьмеричную строку.
-   **open(le, mode='r', buering=None, encoding=None, errors=None, newline=None, closefd=True)** - открывает файл и возвращает соответствующий поток.
-   **ord(с)** - код символа.
-   **pow(x, y[, r])** - идентично выражению ( x \*\* y ) % r.
-   **reversed(object)** - итератор из развернутого объекта.
-   **repr(obj)** - представление объекта.
-   **print([object, ...], \*, sep=" ", end='\\n', le=sys.stdout)**- вывод результата на экран.
-   **property(fget=None, fset=None, fdel=None, doc=None)**- возвращает специальный объект дескриптора.
-   **round(X [, N])** - округление до N знаков после запятой.
-   **setattr(объект, имя, значение)** - устанавливает атрибут объекта.
-   **sorted(iterable[, key][, reverse])** - отсортированный список.
-   **staticmethod(function)** - статический метод для функции.
-   **sum(iter, start=0)** - сумма членов последовательности.
-   **super([тип [, объект или тип]])** - доступ к родительскому классу.
-   **type(object)** - возвращает тип объекта.
-   **type(name, bases, dict)** - возвращает новый экземпляр класса name.
-   **vars([object])** - словарь из атрибутов объекта. По умолчанию - словарь локальных имен.
-   **zip(\*iters)** - итератор, возвращающий кортежи, состоящие из соответствующих элементов аргументов-последовательностей.

